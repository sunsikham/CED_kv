좋아. **FV/논문 참조 없이**, 지금까지 합의한 큰 방향(= **relation state를 KV‑prefix로 추출**, 방법은 **CED‑KV**)을 **“실행 가능한 단계별 플랜 + 단계별 실행 목록(체크리스트)”** 형태로 내려볼게.
아래 플랜은 **테스크/모델 스펙을 아직 안 박아도** 돌아가게 “결정 지점(Decision gate)”을 내장해두는 방식이다.

---

# CED‑KV 실행 플랜 (큰 단계 → 실행 목록)

## Phase 0 — “성공 정의”와 실험 하네스 고정 (테스크 불확정 상태에서도 가능)

### 목표

CED‑KV가 “관계‑상태”를 뽑았는지 판단할 수 있는 **정량 기준/계측 루프**를 먼저 만든다.
(여기서 실패하면 이후는 다 디버깅 지옥이 됨)

### 산출물

* **지표 3종**(최소):

  1. **ON 성능**: teacher(데모 포함) vs student(KV‑prefix만) 성능/분포 차이
  2. **OFF 무해성**: prefix ON/OFF의 **effect**(출력분포 변화)
  3. **해석성**: 슬롯별 top‑k 토큰/청크 + 슬롯 중복/붕괴(collapse) 지표
* **평가 루프**: “에피소드 생성 → state 생성 → ON/OFF 평가 → 리포트” 자동화

### 실행 목록

* [ ] **Teacher / Base / Student**를 코드 레벨로 명확히 분리

  * Base: 상태 없이 질의
  * Teacher: 데모 포함(혹은 데모 KV 캐시)로 질의
  * Student: 데모 없이 (s_e^{(S)})만 붙여 질의
* [ ] ON 질의, OFF 질의의 **최소 샘플 규격** 정의

  * ON: “관계 질의”로 간주되는 포맷만 고정(세부 태스크는 나중)
  * OFF: 일반 문장/잡질의(도메인 불문) 샘플러만 준비
* [ ] OFF 무해성 지표를 **effect 기반**으로 고정
  [
  \Delta(u)=\mathrm{KL}\big(p(\cdot|u,s_e)\ |\ p(\cdot|u)\big)
  ]

  * OFF에서 (\Delta(u))가 작아야 함
* [ ] 리포트 템플릿(표준 출력) 만들기

  * ON 성능, OFF 평균/상위 1% (\Delta), 슬롯 붕괴율, 슬롯별 top‑k 토큰

**Decision gate (Phase 0 통과 조건)**

* Teacher/Base/Student가 동일 입력에서 **재현성 있게** 돌고,
* OFF에서 “상태 ON/OFF 차이”를 (\Delta)로 안정적으로 측정 가능해야 함.

---

## Phase 1 — KV‑prefix 주입/추출 “관로” 완성 (CED‑KV 전용 인프라)

### 목표

CED‑KV는 결국 **(1) 데모 forward로 토큰별 KV를 얻고 (2) 슬롯 KV로 재조립해서 (3) past_key_values로 주입**하는 파이프라인이 핵심이므로, 이 관로를 먼저 완성한다.

### 산출물

* 데모 토큰별 (K/V) 텐서 덤프
* 임의의 (s_e^{(S)})를 만들어 **student**로 주입 가능한 코드
* (중요) RoPE/포지션 처리 “임시 안전모드”

### 실행 목록

* [ ] 데모를 1회 forward 해서 **토큰별 KV**를 얻는 함수

  * layer × head × token × dim 형태로 저장
* [ ] **past_key_values 포맷**으로 prefix 슬롯(K/V)을 넣고 질의를 돌리는 함수
* [ ] “prefix 길이 S”가 바뀌어도 position index가 깨지지 않게 처리
* [ ] RoPE 안전모드(초기에는 복잡한 raw‑mix를 안 해도 됨)

  * **초기 안전모드 권장:** “KV를 직접 섞지 않는” 구성(= Select‑KV / chunk 단위 그대로 복사)로 먼저 end‑to‑end 동작 확인
  * 이후 Phase 3에서 raw‑mix로 들어감

**Decision gate**

* “아무 슬롯 KV”를 넣었을 때, ON/OFF 지표가 변하고(=주입이 실제로 작동),
* seed 고정 시 재현성이 있어야 함.

---

## Phase 2 — CED‑KV v0: **Select‑KV(1‑hot) / Chunk‑Select**로 “관계‑상태 추출” 첫 성공

> CED‑KV의 본질을 지키면서 가장 빨리 성공하는 v0는 “convex mixture” 이전에 **‘선택(select)’** 이다.
> 이 단계는 성능이 목적이 아니라 **관계‑상태 추출이 가능한지**를 확인하는 단계.

### 목표

* 슬롯이 “데모의 실제 KV 조각”을 대표하게 만들고
* ON에서 이득이 생기며
* OFF에서 부작용이 과도하지 않게 만들기

### 산출물

* 슬롯 = 데모 토큰(혹은 청크)의 KV를 그대로 복사한 (s_e^{(S)})
* 슬롯 선택 기준 2~3개(휴리스틱/스코어링)

### 실행 목록

* [ ] 후보 집합 (C)를 “안전한 기본”으로 구성(일단 넓게)

  * 입력 토큰 + 경계 토큰(구분자) 중심
  * 출력 토큰은 v0에서는 **제외하거나 비중 낮게**(pair lookup 경로를 줄이기)
* [ ] 슬롯 선택 규칙(최소 2개)

  * (a) teacher에서 ON 질의 시 **prefix로 주는 attention/attribution**이 큰 토큰/청크 우선
  * (b) “구분자 주변/매핑 힌트 구간” 우선(태스크 불문 안정적)
* [ ] 슬롯 다양성 규칙(중복 방지)

  * 같은 주변 토큰만 뽑히는 collapse를 막는 간단한 거리 기반 억제
* [ ] ON/OFF 리포트로 “상태가 의미 있게 작동하는지” 확인

**Decision gate**

* Select‑KV만으로도 ON 성능이 올라가고(teacher 쪽으로),
* OFF에서 (\Delta(u))가 폭발하지 않는 조합이 존재해야 한다.
  → 없으면 “관계가 KV‑prefix로 표현 가능한지” 자체가 흔들림.

---

## Phase 3 — CED‑KV 본체: **Sparse Convex Mixture (a_{s,j})** + 안정 최적화

이제 “슬롯 = 희소 convex 조합”을 실제로 구현한다.

### 목표

* 슬롯마다 (a_{s,\cdot})를 학습/추정해서
  “데모 KV의 chunking”이 자동으로 되게 만들기
* 자유 KV 발명은 금지(출처는 항상 데모)

### 산출물

* (a_{s,j}) 파라미터화 + top‑k 희소화
* 학습 루프(에피소드별 최적화) v1

### 실행 목록

* [ ] (a_{s,\cdot}) 파라미터화

  * 기본: (w_{s,j}) 학습 → softmax → top‑k 마스킹
* [ ] 로스 v1 (최소 3항)

  1. (L_{\text{on}}): teacher 동치(로그릿 KL)
  2. (L_{\text{off}}): effect‑gating(OFF에서 (\Delta(u)) 최소화)
  3. (L_{\text{str}}): 희소/다양성(슬롯 collapse 방지)
* [ ] “쌍 암기/정답 복사” 경로 차단 장치(초기 기본값)

  * V 후보를 입력/힌트 토큰 중심으로 제한(출력 토큰 value 사용을 약화)
* [ ] 최적화 안정화

  * 초기화: Select‑KV 결과를 warm‑start로 사용(가장 효과적)
  * gradient clipping, 학습률 스케줄 최소 구성

**Decision gate**

* Select‑KV 대비 **같은 S에서 ON 성능이 개선**되거나,
* 같은 ON 성능에서 **더 작은 S**가 가능해야 함.
* 동시에 OFF (\Delta)가 관리되어야 함.

---

## Phase 4 — “선택적 호출”을 **proxy가 아닌 effect 기반**으로 완성 + OFF 하드네거티브 채굴

여기서부터가 “관계‑상태”가 진짜 모듈로 성립하는지의 핵심.

### 목표

* 관계 질의에서만 prefix가 “실제로” 영향력을 행사하고
* 일반 문장에서는 영향력이 거의 0

### 산출물

* OFF 하드네거티브 채굴 루프
* 게이팅 기준(허용 임계치) 설정

### 실행 목록

* [ ] OFF 샘플을 버킷화(길이/문체/형식)해서 커버리지 확보
* [ ] (\Delta(u))가 큰 OFF 샘플을 **자동 채굴**(hard negative mining)
* [ ] “ON에서의 유효 영향”도 계측

  * ON에서 prefix ON/OFF의 (\Delta(x))가 너무 작으면 “안 쓰는 상태”임
* [ ] 운영 임계치(가드레일) 설정

  * OFF: 상위 1% (\Delta) 상한
  * ON: 최소 효과 (\Delta) 하한(너무 작으면 관계 상태가 아니거나 무시되는 상태)

**Decision gate**

* OFF worst‑case에서 안정성이 유지되면서 ON 성능이 유지되어야 함.
* 여기서 trade‑off가 심하면, 다음 Phase에서 표현/구조를 조정한다.

---

## Phase 5 — 표현력 부족/붕괴 문제 대응: “최소 자유도” 확장 (CED 철학 유지)

CED‑KV의 철학(발명 금지)을 유지하면서 성능 병목을 푸는 단계.

### 목표

* convex mixture만으로 부족할 때의 상한을 올리고
* slot collapse/중복을 줄인다

### 산출물 (선택지 중 1~2개만 채택)

* (옵션 1) **V‑only 저랭크 변환**(slot마다 작은 선형 게인/저랭크)
* (옵션 2) **계층형 chunking**(토큰→청크→슬롯)
* (옵션 3) 레이어 공유/부분 레이어만 prefix 적용(안정/효율)

### 실행 목록

* [ ] 병목 진단

  * “S 늘리면 성능은 오르는데 S 작으면 급락”이면 표현력 부족
  * “슬롯들이 같은 토큰만 먹는다”면 collapse
* [ ] V‑only 변환(최소 자유도) 추가 후 OFF 안정성 재점검
* [ ] 계층형 chunking 추가(슬롯 해석 가능성 유지)

**Decision gate**

* OFF 무해성(가드레일)을 깨지 않으면서 ON 성능/S 효율이 개선되는지.

---

## Phase 6 — 에피소드별 backprop 부담 해소: **Amortized CED‑KV (추출기)**

여기서부터는 “연구 프로토타입”에서 “실제로 쓰는 모듈”로 넘어간다.

### 목표

* 에피소드마다 최적화하지 않고, **한 번에 (a_{s,j})** 를 뽑는 추출기를 만든다
* 필요하면 몇 step만 보정(few‑step refine)

### 산출물

* 상태 추출기 (g(e)\rightarrow a)
* (옵션) refine step

### 실행 목록

* [ ] 학습 데이터 구성: (에피소드, 최적 (a)) 페어 로그 구축
* [ ] 추출기 구조: “set encoder + slot attention”류의 형태(데모 순서/길이 변화에 강하게)
* [ ] 추출기 출력에 희소/다양성 제약 내장
* [ ] 추출기만으로 ON/OFF를 맞추는지, refine이 필요한지 판단

**Decision gate**

* 온라인 비용이 줄고, 성능/안정성이 유지되면 “실현 단계”로 진입 가능.

---

## Phase 7 — 패키징/운영: state 캐시, 정밀도, 재사용 정책

### 목표

* (s_e^{(S)})를 “저장/전송/캐싱 가능한 artifact”로 만든다.

### 실행 목록

* [ ] state artifact 스펙 확정: layer별 K/V 텐서 + 메타데이터(S, dtype, 모델버전, position 규칙)
* [ ] 저장 정밀도(fp16/bf16/int8) 실험(OFF 영향 포함)
* [ ] 캐시 키 설계(에피소드 해시/데모 요약 해시 등)
* [ ] 멀티‑질의 재사용 안정성 확인(드리프트/누적 효과 점검)

---

# 전체 플랜을 관통하는 “실행 원칙” 5개 (CED‑KV가 무너지지 않게)

1. **항상 베이스라인 2개를 같이 둔다**

   * Free‑KV(성능 상한) / Select‑KV(보수적 하한)
     → CED‑KV가 “의미 있는 중간해”인지 바로 판정 가능
2. 게이팅은 가능한 한 **effect 기반((\Delta))** 으로 정의한다
   → attention mass는 디버깅 신호로만
3. v0에서는 **출력 토큰을 value 후보에서 배제/약화**해 “정답 복사” 경로를 먼저 죽인다
4. 최적화는 무조건 **warm‑start(Select‑KV)** 로 시작한다
   → 로컬해/불안정 크게 감소
5. OFF는 랜덤 샘플링으로 끝내지 말고 **hard negative 채굴 루프**를 초기에 붙인다

---

# 바로 실행 가능한 “작업 목록(Top‑down)” 요약

* (P0) 평가 하네스/지표 고정
* (P1) KV 추출/주입 관로 완성
* (P2) Select‑KV로 end‑to‑end 첫 성공
* (P3) Sparse convex mixture + 3항 로스(on/off/struct)
* (P4) effect‑gating + OFF hard negative
* (P5) 표현력/붕괴 보완(최소 자유도)
* (P6) amortized extractor + (옵션) refine
* (P7) artifact/캐싱/정밀도/재사용 운영

---

원하면 다음 메시지에서, 위 플랜을 **“구체적 실행 티켓” 형태**로 더 잘게 쪼개서(예: GitHub 이슈처럼)
각 티켓마다 **입력/출력/완료조건(DoD)/리스크/로그 항목**까지 붙여줄 수 있어.
